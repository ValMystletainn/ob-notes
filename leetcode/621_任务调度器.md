---
created: 2023-03-25 08:54
aliases: []
tags:
  - leetcode
  - greed 
---

# Description

给你一个用字符数组 `tasks` 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个 **相同种类** 的任务之间必须有长度为整数 `n` 的冷却时间，因此至少有连续 `n` 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的 **最短时间** 。


# Solution

## 贪心构造(三叶)

这里要和三种饮料接水，每次最多开两个龙头的题目区分开。在那个题目中，将不同类任务归并，是可以将任务用时从$1 + 1$变成$1$的，而在这里，应该说明的事是，每个任务用时的`1`是不可压缩的了，要压缩的部分，其实只有冻结的时间。

如果我们只有一类任务，那任务排期如下：

![621_任务调度器_只有一类任务](https://pic.leetcode.cn/1666687680-aCVvro-image.png)

所需用时是任务数$(m - 1) * (n + 1) + 1$。这是因为最后一个任务和其他任务不同，它如果完成了，就不需要再空等等待时间了，这时候任务队列已经空了。

那由此呢，再考虑加入两种任务，一种是数量等于最大数目的任务，一种是少于它的任务。那自然的，可以插入在这里A后面的等待间隙中

![621_任务调度器_多类任务](https://pic.leetcode.cn/1666689295-VuBpQL-image.png)

如果增加的某类任务，其数量和最多数量的任务数相等时，则会在最后一行也添加进去，导致$(m - 1) * (n + 1) + 1$变成了$(m - 1) * (n + 1) +$数量为最大值的任务种类数。

此外再看右图，当细碎的任务多到一定程度，使得由最多任务生成的空槽格填满也装不下所有任务的时候，我们把这些细碎任务排到外面，能保证cpu在冷却期后及时地处理任务。那这个时候的数量如何统计呢？如果还陷在这张图里，可能就会做成很复杂的一串逻辑代码，但其实跳出来看，就很简单了。这种情况下，cpu其实完完全全没有空载的冷却时间，每时每刻都在处理任务。所以其实，这个时候，处理的最短时间就是任务总数。

所以综上，我们的答案，就是1. 这样产生的表格的格子数 2. 任务总数  两者取最大值即可。

```python
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        task_cnt = Counter(tasks)
        max_freq_cnt = max(task_cnt.values())
        max_freq_task_spec = 0
        for v in task_cnt.values():
            if v == max_freq_cnt:
                max_freq_task_spec += 1
        return max(len(tasks), (n + 1) * (max_freq_cnt - 1) + max_freq_task_spec)
```
