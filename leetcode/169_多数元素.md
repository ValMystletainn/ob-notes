---
created: 2023-03-18 10:19
aliases: []
tags:
  - leetcode 
  - voting_method
---

# Description

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**进阶**： 尝试设计时间复杂度为O(n)，空间复杂度为O(1)的算法解决此问题

# Solution

由题设自然可以想到的方法是哈希表给出现的元素计数，并取出频数最大的。这也是求常规众数的方法，但显然，这个方法并没有利用到出现次数大于`⌊ n/2 ⌋`的条件。

满足本题空间复杂度的算法是摩尔投票法(Boyer-Moore voting algorithm)。直观上来说，算法是通过以下观察推演的，若把待求数看成是$+1$票，而其他数看成是$-1$票，那么求和起来的数一定大于$0$。

而现在考虑这样简化

若某个前缀子数组，其满足的性质是，有一个元素的频数恰巧是50%。那么删去这个子数组并不改变结果。其原因如下(以下参考糖水不等式，把数组全长看成水，把频数最大元素看成糖)：
1. 若这个50%的元素不是最终答案，则这部分含糖量小于50%更小于总含糖量，后面那块子数组的含糖量会比全数组含糖量更高，原始的答案也会是删去前缀子数组后的后缀子数组的答案
2. 若这个50%的元素是最终答案，则这部分答案等于50%，但从题设，全数组含糖量大于50%，所以删去这块后得到的后续数组的含糖量更高，也类似，原始的答案也会是删去前缀子数组后的后缀子数组的答案

代码实现时，维护两个变量，表示当前元素和元素对消频数和来执行。若元素对频数和为0，则说明有一块元素频数恰巧是50%的片段，直接删去，则可以尝试将下一个元素，尝试放为当前元素，查看它在后半段的占比是否高过50%

时间复杂度$O(n)$, 空间复杂度$O(1)$

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        result = nums[0]
        cnt = 0
        for num in nums:
            if cnt == 0:
                result = num
                cnt = 1
            elif num == result:
                cnt += 1
            else:
                cnt -= 1
        return result
```
