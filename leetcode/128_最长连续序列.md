---
title: 128_最长连续序列
created: 2023-03-24 13:22
aliases: []
tags:
  - leetcode 
  - hash 
---

# Description

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n) `的算法解决此问题。

**示例1**：

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```



# Solution

本题很容易想到$O(n\log n)$的解法，就是排序后，从左到右遍历，如果下一个数不是上一个数+1，则说明到了一段新的连续序列，则将上一个序列的长度结算，并维护最大值，然后新起一个序列长度的计数即可。

以上问题抽象出来是说，我们核心要进行的步骤，是抽取一个$x$，然后反复查验$x+1, x+2, \dots , x+k$是否在数组中，则得到了以$x$为左端点，长度为$k + 1$的连续序列。所以进来到了本题的第一个优化点，将数组变成一个哈希表，加快查询的速度。然后顺次就来到了第二个优化点，就是枚举所有元素，查看其作为左端点，是一个相对低效，有重复计算的行为，比如以上查询中，我们再枚举$x + 1$为左端点的时候，长度为$k$，一定会比$x$作为左端点的时候小。所以，这里就来到了第二个优化点，如果$x - 1$存在于哈希表中，则说明$x$肯定不是局部最优点，至少能优化成以$x - 1$为起点，得到更长的连续子序列，就没必要以它为起点计算长度了。

在这样的场景下，每个元素$x$至少在尝试枚举左端点的时候访问一次，在$x + 1$被枚举后(如果有)检查是否存在$x$时访问一次，在举到了它所在的连续子序列的起点，后递增记长度时，又访问了一次。所以时间复杂度为$O(n)$，空间复杂度也为$O(n)$
 
```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        num_set = set(nums)
        result = 0
        for num in num_set:
            # invalid start
            if num - 1 in num_set:
                continue
            
            curr_len = 1
            while num + 1 in num_set:
                curr_len += 1
                num += 1
            result = curr_len if curr_len > result else result
        return result
```
