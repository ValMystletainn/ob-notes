---
created: 2023-03-25 09:42
aliases: []
tags:
  - leetcode 
  - sort
---

# Description

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi`，前面 **正好** 有 `ki `个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列最前面的人）。

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```

# Solution

## 排序+插入(官解1)

本题的解的玄机，如果用一句话概括的话就是“高的人是看不到矮的人的”。

具体来说是这样的，如果我们尝试重建队列，按身高从高到低的顺序，依次为大家找寻在队列中合适的位置。在这个顺序下，当第$i$个人尝试入队的时候，已经入队的人一定是身高大于等于他的人，所以根据他期望的他身前有的比他高的人`ki`，直接将其插入到位置`ki`就可以满足他的要求。而又因为这个人比队列中的其他人都矮，所以他插入后，不会影响到他前面/后面的，比他高的人的计数。

在具体考虑要求是`ki`的计数也包括身高相等的人的以后，我们就得到了如下排序入队顺序，主键是升高从高到低排序，副键是`k`，从低到高排序，这样可以保证等身高的人里的插入顺序是`k`从小到大排序，保证了大的`k`的人会插入在小`k`的人的后面，从而不影响小`k`的人的计数

时间复杂度$O(nlogn) + O(n^2)=O(n^2)$分别为排序和插入的用时，空间复杂度$O(n)$为答案数组的大小

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key=lambda x: (-x[0], x[1]))
        result = []
        for p in people:
            if len(result) <= p[1]:
                result.append(p)
            else:
                result.insert(p[1], p)
        return result
```
